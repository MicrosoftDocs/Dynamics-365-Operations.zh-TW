---
title: 改善排程引擎效能
description: 本主題介紹排程引擎以及如何改善效能。
author: ChristianRytt
ms.date: 09/03/2020
ms.topic: article
ms.prod: ''
ms.technology: ''
ms.search.form: ''
audience: Application User
ms.reviewer: kamaybac
ms.custom: 19311
ms.assetid: 5ffb1486-2e08-4cdc-bd34-b47ae795ef0f
ms.search.region: Global
ms.search.industry: ''
ms.author: crytt
ms.search.validFrom: 2020-09-03
ms.dyn365.ops.version: ''
ms.openlocfilehash: 2495339f25469af705cff841f090c5df95b4d996
ms.sourcegitcommit: 3b87f042a7e97f72b5aa73bef186c5426b937fec
ms.translationtype: HT
ms.contentlocale: zh-TW
ms.lasthandoff: 09/29/2021
ms.locfileid: "8449112"
---
# <a name="improve-scheduling-engine-performance"></a>改善排程引擎效能

[!include [banner](../includes/banner.md)]

資源排程引擎用於計劃和下達生產訂單的途程排程。 該引擎最初是作為 Dynamics AX 2012 的一部分發行，自發行以來經歷了多次改善。

[零工式排程問題](https://en.wikipedia.org/wiki/Job_shop_scheduling)是一個極其複雜的組合問題，其解決方案時間隨著決策變數的數量呈指數增長。 通常，客戶設定生產途程和相關資料的方式會導致排程問題，即使在最新的硬體上也無法在合理的時間內解決該問題。 本主題將幫助您了解排程引擎以及特定設定如何影響效能。

在改善排程效能方面，一般指南建議降低引擎需要解決的問題的複雜性。 可能影響效能的一些主要因素包括：

- 包含許多工序的途程
- 包含平行工序的途程
- 資源數量大於 1 的工序
- 具有許多適用資源的工序
- 使用硬連結
- 使用有限產能
- 使用不同的行事曆數量
- 行事曆中每天的工作時間段數
- 途程總持續時間
- 平行執行多個排程引擎

## <a name="overview-of-basic-scheduling-flow"></a>基本排程流程概觀

若要了解指定的設定如何影響效能，重要的是要了解流程在引擎內部和圍繞它的 X++ 代碼中如何執行的資訊。

排程訂單的基本流程包括三個主要步驟：

- **載入資料** - 在這裡，X++ 資料模型將以作業和條件約束的形式轉換為引擎的內部資料模型。
- **排程** - 這是處理指定模型和條件約束並產生結果的排程的主要來源。 在此流程中，引擎會根據需要從 X++ 中要求工作時間資訊和現有產能預留。
- **儲存資料** - 作業產能預留時段形式的引擎結果由 X++ 代碼處理，以節省產能預留並更新作業/工序/訂單的開始和結束時間。

## <a name="load-data-into-the-engine"></a>將資料載入到引擎中

排程引擎具有比 Supply Chain Management 資料庫更抽象的資料模型，因為它已建置為可以處理不同資料來源的通用引擎。 途程、次要工序和執行時間的概念需要「轉換」為引擎公開的通用作業和條件約束模型。 建置模型的邏輯具有大量的業務邏輯，並且根據來源資料而有所不同。 可靠的 X++ 類別是 `WrkCtrScheduler`，其具有計劃生產訂單、下達生產訂單和專案預測的衍生類別。

例如，考慮下表和影像中顯示的途程，這似乎相對簡單。

| 工序。 編號 | 優先順序 | 設定時間 | 執行時間 | 之後的排隊時間 | 資源數量 | 下一步 |
| --- | --- | --- | --- | --- | --- | --- |
| 10 | 主要 | 1.00 | 2.00 | | 1 | 20 |
| 10 | 次要&nbsp;1 | | | | 1 | 20 |
| 20 | 主要 | | 3.00 | 1.00 | 3 | 0 |

![範例途程圖。](media/scheduling-engine-route.png "範例途程圖")

將其傳送到引擎後，它被分成八個作業，如下圖所示 (選取影像以放大)。

[![排程引擎作業](media/scheduling-engine-jobs.png "排程引擎作業。")](media/scheduling-engine-jobs-large.png)

兩個作業之間的標準連結是 `FinishStart`，這代表一個作業的結束時間必須在另一個工作的開始時間之前。 因為設定必須由稍後將執行該流程的同一資源執行，所以它們之間存在 `OnSameResource` 條件約束。 在編號為 10 的主要工序的次要工序之間，有 `StartStart` 和 `FinishFinish` 連結，這代表作業必須同時開始和結束，並且有 `NotOnSameResource` 條件約束，這將防止主要和次要資源使用相同的資源。

對於工序 20 (資源數量已設定為 3)，已將流程作業拆分為三個不同的作業，其中所有作業必須在同一時間執行。
在這種情況下，途程群組已設定為不為之後的佇列預留產能，這就是為什麼之後的佇列只有一個作業的原因。

排程引擎僅了解作業的概念，不了解工序的概念。 這代表在進行工序排程時，這些工序也將拆分為作業，儘管這些不會保存在資料庫中。

對於每個作業，我們還將定義作業產能要求是什麼 (所需的秒數)。 根據資源要求的定義方式，我們還可以針對每個作業傳送一份清單，其中列出了該作業可以在其上執行的所有潛在適用資源以及該特定資源的產能要求。 即使在建置模型時傳送了適用資源的清單，引擎仍需要確保資源指派在整個作業持續時間都有效。

## <a name="scheduling-engine-internals"></a>排程引擎內部

### <a name="scheduling-engine-interface"></a>排程引擎介面

若要了解引擎在內部的運作方式，最好查看其在外部公開的功能。 在 X++ 中，主介面是 `WrkCtrSchedulerEngineInterface`. 其具有以下小節中描述的方法。

#### <a name="general-engine"></a>通用引擎

| **方法** | **目的** |
| --- | --- |
| `run` | 排程所有載入的作業並傳回錯誤碼。 |
| `getJobSchedulingSequenceResult` | 取得排程結果和特定作業識別的序列中的和第一個錯誤作業。 |
| `validateJobCapacityReservations` | 驗證引擎存儲的所有作業的產能預留。 |
| `setReservationsTimeStamp` | 在引擎的快取中，將時間戳記傳送到在排程作業的所有新產能預留上設定的引擎。 |
| `addPropertyToGroupAggregation` | 將屬性首碼新增到彙總產能時使用的屬性集。 |
| `addResource` | 將資源新增到排程引擎資源池。 |
| `addResourceGroup` | 將資源群組新增到排程引擎資源群組池。 |
| `addResourceGroupMembership` | 將資源做為成員新增到資源群組。 |
| `addOptimizationGoal` | 新增排程最佳化目標 (持續時間或優先順序)。 |

#### <a name="individual-jobs"></a>單獨作業

| **方法** | **目的** |
| --- | --- |
| `addJobInfo` | 新增作業資訊記錄，以通知引擎應該安排的作業。 |
| `addConstraintJobEndsAt` | 新增作業應在指定日期和時間結束的條件約束。 |
| `addConstraintJobStartsAt` | 新增作業應在指定日期和時間開始的條件約束。 |
| `addConstraintMaxJobDays` | 定義作業可以跨越指定的最大天數的條件約束。 |
| `addConstraintResourceRequirement` | 新增必須在特定資源上排程作業的條件約束。 |
| `addJobBindPriority` | 為 (作業，條件約束等級) 對新增作業繫結優先順序。 較高的優先順序值代表作業變數將更早地繫結。 該作業將在具有相同序列但優先順序值較低的作業之前處理。 |
| `addJobCapacity` | 新增作業的產能負載資訊 (如所需的作業執行階段)，與作業在哪個資源上執行無關。 |
| `addJobResourceCapacity` | 將資源新增到可用於執行作業的資源集中，並說明在該資源上執行時所需的產能。 |
| `addJobGoal` | 新增特定條件約束等級 (最早結束時間或最晚開始時間) 的作業目標資訊。 |
| `addJobResourcePriority` | 新增在資源上排程作業時要使用的優先順序。 |
| `addJobResourceRuntime` | 指定作業時間，該時間取決於將在其上排程作業的資源。 |
| `addJobRuntime` | 指定作業時間，該時間與將在其上排程作業的資源無關。 |
| `scheduleJobOnResourceGroup` | 在資源群組等級標記要排程的作業。 |
| `setJobResourcePreemptionAllowed` | 設定資源上的作業是否允許搶佔 (如果允許引擎將作業安排在不連續的產能時段中)。 |
| `setRequiredNumberOfResources` | 設定排程作業所需的資源數量 (僅用於工序排程)。 |

#### <a name="constraints-between-jobs"></a>作業之間的條件約束

| **方法** | **目的** |
| --- | --- |
| `addJobLink` | 在兩個工作之間新增連結 (如完成\>開始)。 |
| `addConstraintEndsDelayed` | 定義一個作業不能在另一個作業結束加上一些延遲時間之前結束的條件約束。 |
| `addConstraintJobListWorkingTimeIntersect` | 新增條件約束，為作業預留的產能時段必須在作業使用的兩個資源的相交工作時間上。 |
| `addConstraintJobOverlap` | 新增約束，定義當指定數量的品項可以在兩個資源之間移動，而第一個資源仍未完成處理時如何排序作業，以便第二個資源可以開始處理。 |
| `addConstraintNotOnSameResource` | 新增不應在同一資源上排程兩個作業的條件約束。 |
| `addConstraintOnSameResource` | 新增兩個作業應使用同一資源的條件約束。 |
| `addJobSameReservations` | 新增條件約束，即作業最終必須具有與主要作業相同的時間段的產能預留。 |
| `setPrimaryParallelJob` | 新增有關在一組平行作業中哪些作業是主要作業的資訊。 |

### <a name="solver"></a>求解工具

引擎本質上是新增了自訂啟發的專用條件約束求解工具。 求解工具以兩個主要元素為基礎：變數和條件約束。

#### <a name="variable"></a>變數

變數表示可能值的網域。 排程引擎有兩種類型的變數：

- **日期時間變數** - 具有所有日期和時間的網域，並且可以透過移動變數時間的下限和上限以使其相互靠近來限制該網域。
- **資源變數** - 具有適用資源的網域，並且可以透過從清單中刪除資源來限制該網域。

#### <a name="constraint"></a>條件約束

條件約束透過限制變數的網域來作用於變數，但它也依賴於變數，因此當變數發生變化時會啟動它。 「條件約束傳播」的流程是條件約束執行其主要功能，並在成功時向主邏輯報告。

當變數無法進一步限制時，就會視為繫結的，對於日期時間變數來說，這代表上限和下限是相同的，對於資源變數來說，它只有一個適用的資源。 當所有變數都繫結時，就會找到解決方案。

### <a name="constraint-levels"></a>條件約束等級

當排程做為物料要求計劃 (MRP) 覆蓋階段的一部分執行時，訂單將從要求日期逆向排程。 但是，如果找不到從今天或之後開始，並在要求日期之前結束的排程，則排程方向將從今天開始變更為正向。

透過組織等級中的條件約束來處理此主要業務規則。 如果在使用最高等級的條件約束時沒有找到解決方案，則該等級的約束都將丟棄，並嘗試使用較低的等級。 在實踐中，這代表對於逆向排程，模型將包含等級 1，具有最晚開始時間和指定最大結束時間條件約束 (要求日期) 的作業目標，以及包含等級 0，具有最早結束時間和指定最小開始時間條件約束 (今天) 的作業目標。

### <a name="algorithm"></a>演算法

引擎演算法的主要步驟是：

1. 尋找可以單獨解決的序列 (作業鏈)。
1. 嘗試為最高條件約束等級的序列找到初始解決方案。
    1. 根據作業目標和優先順序排序作業，以便找到起始工作。
    1. 按以下序列循環作業：
        1. 尋找所有需要傳播的條件約束並執行傳播。
        1. 如果作業的所有變數都已繫結，則已找到該作業的解決方案。
        1. 如果在不違反條件約束的情況下無法繫結變數，則復原變數繫結，在網域中嘗試使用的其他值 (對於資源變數)，然後重新執行條件約束傳播。
1. 如果沒有找到解決方案，則移除目前條件約束等級上的所有條件約束，降低條件約束等級 (如果有任何更低等級可用)，並使用新的條件約束集重試解決方案搜尋。
1. 如果找到可行的解決方案，則開始最佳化階段，該階段將嘗試找到更好的解決方案，直到達到最佳化逾時或所有資源群組合已耗盡為止。

條件約束求解工具不知道排程演算法的細節。 正是在各種條件約束的定義和組合產生了魔法。

### <a name="determining-working-times"></a>確定工作時間

引擎中 (內部) 條件約束的大部分將控制資源的工作時間和產能。 本質上，工作是從指定點沿指定方向周遊資源的工作時間段，並找到一個足夠長的時間間隔以使其適應作業所需的產能 (時間)。

為此，引擎需要知道資源的工作時間。 與主要模型資料相反，工作時間為 *延遲載入*，這代表它們會根據需要載入到引擎中。 採用這種方法的原因是，Supply Chain Management 中行事曆的工作時間通常很長，且常存在許多行事曆，因此預先載入的資料會非常大。

引擎透過較用 X++ 類別方法 `WrkCtrSchedulingInteropDataProvider.getWorkingTimes` 以區塊形式要求行事曆資訊。 該要求針對特定時間間隔內的特定行事曆識別碼。 根據 Supply Chain Management 中伺服器快取的狀態，每個要求中最終都可能叫用多個資料庫，這需要很長時間 (相較於純計算時間)。 此外，如果行事曆包含非常詳盡的工作時間定義，且每天有許多工作時間間隔，則這會增加載入時間。

當工作時間資料載入到排程引擎中後，該資料會保留在特定行事曆的內部快取中，這代表如果任何其他作業或資源正在使用同一行事曆，則可以從內存中快速執行下一次查詢。 效能不佳的一個常見原因是，如果為每個資源使用單獨的行事曆識別碼，則即使行事曆的內容可能相同，也都需要為每個行事曆要求資料。

### <a name="finite-capacity"></a>有限產能

使用有限產能時，行事曆中的工作時間段會根據現有的產能預留進行拆分和減少。 也透過相同的 `WrkCtrSchedulingInteropDataProvider` 類別擷取這些預留做為行事曆，但改為使用方法 `getCapacityReservations`。 在主計劃期間進行排程時會考慮特定主計劃的預留，如果已在 **主計劃參數** 頁面上啟用它，還包括確定的生產訂單中的預留。 同樣，在排程生產訂單時，也可以選擇包括現有計劃訂單的預留，儘管這不像其他方式那樣常見。

由於以下幾個原因，使用有限產能會導致排程花費更長的時間：

- 從資料庫中擷取產能資訊是一項緩慢的作業，且產能資訊的伺服器端快取通常不如工作時間好，因為它們通常不像行事曆那樣在資源之間共用。
- 由於拆分，要周遊的工作時間段數量增加，並且通常必須在找到解決方案之前研究較長時間期間的時段。
- 排程完成後，必須檢查預留是否存在衝突 (有關詳細資訊，請參閱「平行執行排程引擎」區段)。

### <a name="examining-the-resource-combinations"></a>檢查資源群組合

如果作業序列僅包含標準 `FinishStart` 連結，這代表它形成一條沒有任何分支的簡單鏈，透過為第一個作業找到最佳解決方案，然後繼續尋找下一個作業找到最佳解決方案，可以實現最佳結果 (從單一訂單看，而不是跨訂單看)。 工作的最佳解決方案代表找到可以取得最接近工作目標的工作開始日期和結束日期的資源 (在正向排程中，這代表盡早獲得工作的結束日期)，同時還要遵守條件約束。

當存在平行作業時，尋找解決方案可能涉及檢查不同的資源群組合。 可能的資源群組合的數量是連接的平行作業的適用資源數量的乘積。 尤其是在從要求日期逆向排程訂單時，邏輯可能需要很長時間才能意識到沒有解決方案可以使平行作業在今天的日期之前完成，因為它需要檢查所有組合，可能有些資源具有更高的效率或其他行事曆可能會產生結果。 這代表如果沒有設定逾時限制，它將執行很長時間才將方向變更為正向。

這種組合邏輯也代表新增更多適用的資源可能會使引擎執行速度緩慢。 如果在進行平行工序和排程無限產能時出現效能問題，則可以透過讓途程設計者決定應使用哪個資源，然後直接在工序上分配資源來部分解決此問題 (因為在大多數情況下，引擎最終總是選擇相同的資源，因此最終結果將是相同的)。

### <a name="hard-links"></a>硬連結

將兩個作業之間的連結類型設定為「硬」連結，確保完成一個作業和開始下一個作業之間沒有時間間隔。 這在以下案例中會很實用，例如在一項作業中加熱金屬，然後在下一項作業中進行處理時，不希望金屬在這兩個作業之間冷卻。

使用標準軟連結和正向排程，如果途程形成一個沒有任何分支的簡單鏈，則可以透過找到滿足其自身條件約束的第一個作業的解決方案，然後沿著該鏈將結束時間從上一個作業傳到到下一個作業，從而獲得結果。 如果目前作業找不到任何產能，則其開始時間將進一步正向推進，而不會對先前的作業產生任何後果，可能會導致作業之間出現時間間隔。 但是，對於相同案例，如果使用硬連結 (尤其是與有限產能相關)，則鏈中後面的一個作業無法找到產能的事實將代表所有先前排程的作業將不得不逐一「拖延」，造成多次重新排程。 尤其是在多個資源高負載的案例下，硬連結會引起連鎖反應，作業之間會相互影響，在結果穩定到可行的排程之前，必須進行反覆運算。

## <a name="running-scheduling-engines-in-parallel"></a>平行執行排程引擎

當執行排程作為使用協助程式的主計劃執行的一部分時，每個主計劃協助程式執行緒也可以執行生產訂單排程工作。 這代表多個排程引擎可以同時執行。 雖然多執行緒通常具有非常顯著的效能優勢，但在排程方面也存在一些功能上的缺點。

在 MRP 中，指定物料清單 (BOM) 等級的所有生產訂單都按要求日期順序安排，這代表應先排程具有最早要求日期的訂單，這樣最有可能獲得可用的資源產能。 但是，如果有多個引擎從未排程訂單清單中進行選擇，則不再保證該序列，因為一個引擎可能比另一個引擎更快完成。

此外，當使用有限產能進行排程時，且當多個引擎執行個體嘗試排程嘗試在相同時間間隔內使用相同資源的訂單時，可能會出現競爭條件。 此類競爭條件的數量將記錄在主計劃記錄頁面上的 **排程衝突** 欄位中。 衝突解決邏輯如下：

- 排程訂單 (無鎖定) 並獲得產能預留。
- 進行鎖定。
- 檢查時間範圍內排程的資源是否存在較新的產能預留。
  - 如果不存在，則寫入產能並釋放鎖定。
  - 如果存在，則釋放鎖定並從頭開始重新排程訂單。

因此，在使用多個引擎執行個體進行排程時，結果不是完全確定的，因為它將取決於每個執行緒的確切時間。

## <a name="operation-scheduling-performance"></a>工序排程效能

從引擎的角度來看，儘管工序排程也稱為粗略的容量規劃，但如果使用有限的產能，可能更難解決該問題，因為需要更多的資料來確定可行性。

資源群組的產能取決於哪些資源是資源群組的成員，以及有多少資源。 資源群組本身沒有任何產能&mdash;只有當資源是群組的成員時，它才有產能。 由於資源群組成員資格會隨時間變化，因此必須每天評估產能。

在工序排程中，資源群組的行事曆用於決定每個工序的開始和結束時間。 這代表資源群組的行事曆限制了可以在一個資源群組中的某一天為一項工序安排多少時間。 與特定資源的行事曆相反，將忽略該資源群組的行事曆效率資料，因為它僅表示開放時間而不是實際產能。

例如，如果某個特定日期的資源群組的工作時間是 8:00 到 16:00，則一項工序對資源群組的負載不能超過 8 小時內能容納的負載，無論資源群組在當天的共有多少可用產能。 但是，可用產能會進一步限制負載。

在計算指定日期資源群組的可用產能時，會考慮同一天資源群組中包含的所有資源的作業排程負載。 對於每個日期，計算如下：

*可用資源群組產能 = 根據行事曆群組中的資源產能&ndash;群組中資源上的作業排程負載&ndash;群組中資源上的工序排程負載&ndash;資源群組上的工序排程負載*

在途程工序的 **資源要求** 索引標籤上，可使用資源群組、資源類型或一個或多個功能的特定資源 (在這種情況下，將使用該資源排程工序)，或者技能、課程或證書來指定資源要求。 雖然使用所有這些選項為途程設計提供了極大的靈活性，但它也使引擎的排程變得複雜，因為必須根據「屬性」 (針對功能、技能等在引擎中使用的抽象名稱) 來計算產能。

功能的資源群組產能是資源群組中具有相關功能的所有資源的產能之和。 如果群組中的資源具有功能，則無論需要什麼等級的功能，都會考慮該資源。

在工序排程中，當資源群組載入需要相關功能的工序時，該資源群組特定功能的可用產能將減少。 如果工序需要一種以上的功能，則所有所需功能的產能都將減少。

對於每個日期，所需計算如下：

*功能的可用產能 = 功能的產能&ndash;資源群組中包含的具有特定功能的資源上作業排程負載&ndash;資源群組中包含的具有特定功能的資源上工序排程負載&ndash;需要特定功能的資源群組本身上的工序排程負載*

這代表如果特定資源上存在負載，則在計算每個功能的資源群組可用產能時會考慮該負載，因為特定資源上的負載會降低其對功能的資源群組產能的貢獻，而無論特定資源上的負載是否針對該特定功能。 如果資源群組等級存在負載，則僅當負載來自需要特定功能的工序時，才會在計算每個功能的資源群組可用產能時考慮該負載。

上述邏輯很複雜，因為這對於每種類型的「屬性」都是相同的，因此使用具有有限產能的工序排程需要載入大量資料。

## <a name="viewing-scheduling-engine-input-and-output"></a>查看排程引擎輸入和輸出

若要取得排程流程輸入和輸出的特定詳細資訊，請移至 **組織管理 \> 設定 \> 排程 \> 排程追踪查核中心** 啟用記錄。

在此頁面上，先在動作窗格上選擇 **啟用記錄**。 然後執行生產訂單的排程。 完成後，返回 **排程追踪查核中心** 頁面並在動作窗格上選擇 **停用記錄**。 重新整理頁面，格線中將出現新行。 選擇新行，然後在動作窗格上選擇 **下載**。 這將為您提供一個包含以下文件的 .zip 壓縮資料夾，其中包含以下文件：

- **Log.txt** - 這是描述引擎執行步驟的記錄檔。 該檔案非常詳盡，內容可能有點多，但是在嘗試途程設定過程中使用它來解決效能問題時，要先尋找的是第一行和最後一行之間的時間差，因為這會為您提供排程程序花費的確切時間。
- **XmlModel.xml** - 這包含在內建於 X++ 中並在其上執行引擎的模型。 該檔案中使用的 `JobId` 與包含作業 (`ReqRouteJob` 或 `ProdRouteJob`) 的來源資料表中的 `RecId` 相關。 在此檔案中通常查看的是，`ConstraintJobStartsAt` 和 `ConstraintJobEndsAt` 中的指定日期符合預期，`JobGoal` 屬性設定正確，和這些作業透過 `JobLink` 條件約束相互關聯。
- **XmlSlots.xml** - 這包含引擎要求的所有工作時間和產能預留。 引擎只會在嘗試放置作業的時間間隔 (和額外緩衝區) 內要求行事曆工作時間和預留，因此如果檔案中包含非常遙遠的未來時間，這可能代表設定有問題。 `ResourceProperty` 節點將顯示每個資源在哪個期間與哪個資源群組和哪些功能相關聯。
- **Result.xml** - 這包含排程執行的結果。

請注意，追蹤功能會大量增加的效能負荷，因此只能將其用於以受控方式調查特定訂單的排程。 如果在主計劃執行期間打開它，將很快達到其大小限制並停止。

## <a name="troubleshooting-performance"></a>效能疑難排解

從先前的所有小節中可以得知，在設定和使用排程引擎方面存在一些陷阱，這可能會導致效能問題。 以下檢查清單可用於解決此類問題。 找出所有問題很重要，因為通常問題是由多種因素造成的。

### <a name="performing-scheduling-as-part-of-mrp-when-it-is-not-needed"></a>在不需要時，將排程做為 MRP 的一部分執行

即使將途程用於生產控制目的 (如成本計算和報告)，在 MRP 期間可能沒有必要考慮它們。 在某些情況下，為品項指定標準生產提前期就足以進行計劃。 若要關閉途程排程，請將產能時間柵欄設定為零。 如果應該進行排程，則必須仔細設定產能時間柵欄，因為可能不需要在 MRP 覆蓋時間柵欄的整個範圍內考慮途程。

請注意，如果在 MRP 期間未排程訂單，則需要在確定計劃訂單時進行排程。 這代表確定流程將花費更長的時間，因此根據有多少建議的排程訂單得到確定，MRP 期間的效能提升可能會在確定時失去。

### <a name="route-with-unnecessary-operations"></a>包含不必要工序的途程

在設計途程時，嘗試用生產流程中的所有步驟對現實世界進行準確地建模很容易。 雖然這在某些情況下很有用，但因為引擎需要處理的模型變得更大 (就作業和條件約束而言)，並且將執行更多 SQL 陳述式來插入和更新作業和產能預留，因此對效能不利。 此外，最終必須報告作業的進度也會產生下游影響，這種影響可以透過自動過帳來緩解。 如果資料沒有任何用途，則會產生不必要的負載。

建議您只建立排程 (通常是瓶頸資源) 和/或成本計算所需的工序。 或者，您應該將許多較小的不同工序組合成一個較大的工序，該工序代表大部分的流程。

### <a name="many-applicable-resources-for-an-operation"></a>工序的許多適用資源

工序的適用資源數量由工序關係上設定的資源要求決定。 該要求可以針對特定 (單獨) 資源，也可以根據資源的資源群組或功能的成員資格。

如果排程不是使用有限產能完成的，並且所有適用的資源都具有相同的行事曆和效率，那麼排程引擎將始終為一個工序選擇相同的資源，但只有在嘗試所有適用的資源後，才能檢查是否有一個資源比其他資源「更好」。 在這種情況下，只需在途程設計時一律將特定資源指派給工序，就可以大大減少排程的負載。

### <a name="route-with-parallel-operations"></a>包含平行工序的途程

雖然平行工序 (主要/次要) 是強大的案例建模工具 (例如可用於當機器和操作員都需要執行特定任務時)，待它也是許多效能問題的根源。 如果將特定單獨資源的要求同時指派給主要和次要工序，通常不會出現問題。 但是，如果每個工序都有許多可能的資源，那麼它將大幅增加排程的計算複雜性。

使用平行工序的替代方法是將這些對建模為「虛擬」資源 (然後這些資源將代表始終一起完成工序的團隊)，或者如果不代表瓶頸，則不對任一工具進行建模。

### <a name="route-with-quantity-of-resources-higher-than-1"></a>資源數量大於 1 的途程

如果將工序所需的資源數量設定為大於 1，則其結果實際上與使用主要/次要工序相同，因為這會將多個平行作業傳送到引擎。 但是，在這種情況下，無法使用特定的資源指派，因為數量大於 1 需要有多個資源適用於該工序。

### <a name="excessive-use-of-finite-capacity"></a>過度使用有限產能

使用有限產能需要引擎從資料庫載入產能資訊，並且可能會產生計算負荷，因為尤其是在資源預訂接近其最大產能的環境中，很難找到解決方案。 因此，仔細評估資源是否真的需要使用有限產能，或它們是否超額預訂非常重要。 由於有限產能資源之間的差異對超額預訂方面的重要性可能所有不同，因此建議對資源使用瓶頸選項，並與計劃中「瓶頸資源的產能時間柵欄」的單獨值結合使用。 使用瓶頸概念可以降低一般的有限產能時間柵欄。

### <a name="setting-hard-links"></a>設定硬連結

途程的標準連結類型是 *軟* 連結，這代表在一個工序的完成時間和下一個工序的開始之間允許有時間間隔。 允許這樣做可能會產生不利影響，如果某項工序在很長一段時間內沒有可用的材料或產能，則生產可能會閒置一段時間，這代表可能會增加正在進行的工作。 硬連結不會發生這種情況，因為結束和開始時間必須完美結合。 但是設定硬連結會使排程問題變得更加困難，因為必須為工序的兩種資源計算工作時間和產能交集。 如果還涉及平行工序，這將大幅增加計算時間。 如果這兩個工序的資源具有完全不重疊的不同行事曆，則該問題將無法解決。

建議僅在絕對必要時才使用硬連結，並仔細考慮該途程的每個工序是否都有必要使用它。

為了在不套用硬連結的情況下減少正在進行的工作，有個訣竅是排程兩次訂單，並在第二次通過時變更為相反的方向。 如果第一個排程是從交貨日期逆向進行，那麼第二個排程應該從排程的開始日期正向進行。 這將導致盡可能壓縮作業，從而最大限度地減少正在進行的工作。

### <a name="separate-calendar-for-each-resource"></a>每個資源的單獨行事曆

排程引擎的主要資料來源之一是行事曆資訊，從資料庫中載入這些資料的成本可能很高。 由於行事曆是根據範本產生的，因此很容易為每個資源產生一個行事曆，然後在資源出現停機和其他問題時調整該行事曆中的資訊。 但是，這樣做會嚴重限制引擎快取行事曆資料的功能，因為它需要為每個資源要求新資料，並且可能是效能問題的主要原因。 相反，建議您在資源之間盡可能重複使用行事曆，然後透過為一段時間指派不同的行事曆識別碼來控制停機變更。

### <a name="high-number-of-working-time-slots-per-calendar-day"></a>每個日曆日的工作時間段數量高

由於引擎透過針對產能逐一檢查時間段來運作，因此將每個日曆日的時間段數量減至最少是有益的。 例如，透過考慮在產生的排程中反映工作人員每小時休息 5 分鐘是否重要可以做到這一點。

### <a name="large-or-none-scheduling-timeouts"></a>較大 (或無) 排程逾時

可使用在 **排程參數** 頁面上找到的參數來最佳化排程引擎效能。 **已啟用排程逾時** 和 **已啟用排程最佳化逾時** 設定應始終設定為 **是**。 如果設定為 **否**，如果建立了具有許多選項的不可行途程，排程可能會無限地執行。

**每個序列的最大排程時間** 的值控制最多可以花幾秒來嘗試為單一序列尋找解決方案 (在大多數情況下，一個序列對應於一個訂單)。 此處使用的值很大程度上取決於途程的複雜性和有限產能等設定，但最好不要超過 30 秒。

**最佳化嘗試逾時** 的值控制最多可以用幾秒來找到比最初找到的解決方案更好的解決方案。 這只會影響使用平行工序的途程，因為這些途程需要測試不同的組合。

> [!NOTE]
> 做為 MRP 的一部分，設定的逾時值將套用於的已下達生產訂單和計劃訂單的排程。 因此，在為具有許多計劃生產訂單的排程時，設定非常高的值可能會大幅增加 MRP 的執行時間。


[!INCLUDE[footer-include](../../includes/footer-banner.md)]